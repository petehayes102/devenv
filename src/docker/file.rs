use std::{
    collections::HashMap,
    fs,
    path::{Path, PathBuf},
};

use anyhow::{Context, Result};
use mustache::{Data, compile_str, to_data};

const FILENAME: &str = "Dockerfile";
const DOCKERFILE: &str = r#"
# Generated by devenv. Do not edit manually.
# Edit devenv.toml and use 'devenv start --rebuild' instead.

FROM {{image}}

WORKDIR /workspace

# Update environment
RUN {{update_env}}

# Install packages
RUN {{package_inst}}{{#packages}} {{.}}{{/packages}}

# Sleep indefinitely to prevent the container from stopping
CMD ["sleep", "infinity"]
"#;

#[derive(Debug, PartialEq)]
pub struct Dockerfile(String);

pub enum OsFamily {
    // Alpine, // @todo
    Debian,
    // Rhel, // @todo
}

impl OsFamily {
    fn update_env(&self) -> &'static str {
        match self {
            // Self::Alpine => "apt -U upgrade",
            Self::Debian => "apt update && apt upgrade -y",
            // Self::Rhel => "dnf update && dnf upgrade -y",
        }
    }

    fn package_inst(&self) -> &'static str {
        match self {
            // Self::Alpine => "apk add --no-cache",
            Self::Debian => "apt install -y",
            // Self::Rhel => "dnf install -y",
        }
    }

    fn base_packages(&self) -> &'static [&'static str] {
        match self {
            // Self::Alpine => &["curl", "ca-certificates", "git", "sudo"],
            Self::Debian => &["curl", "ca-certificates", "git", "sudo"],
            // Self::Rhel => &["curl", "ca-certificates", "git", "sudo"],
        }
    }
}

impl Dockerfile {
    pub fn exists(path: impl AsRef<Path>) -> bool {
        make_path(path).exists()
    }

    pub fn open(path: impl AsRef<Path>) -> Result<Self> {
        let path = make_path(path);
        let contents =
            fs::read_to_string(&path).with_context(|| format!("Reading {}", path.display()))?;
        Ok(Self(contents))
    }

    pub fn create(image: &str, packages: &[String], os: OsFamily) -> Result<Self> {
        let mut data = HashMap::new();
        data.insert("image".into(), Data::String(image.into()));
        data.insert("update_env".into(), Data::String(os.update_env().into()));
        data.insert(
            "package_inst".into(),
            Data::String(os.package_inst().into()),
        );

        let mut pkgs: Vec<String> = os.base_packages().iter().map(|s| (*s).into()).collect();
        packages.iter().for_each(|pkg| pkgs.push(pkg.into()));
        data.insert("packages".into(), to_data(pkgs).unwrap());

        // @todo
        // Optional: create a non-root user inside the image
        // if let Some(user) = dev
        //     .user_name
        //     .as_deref()
        //     .or_else(|| dev.zed_remote.as_ref().and_then(|z| z.ssh_user.as_deref()))
        //     && user != "root"
        // {
        //     let uid = dev.user_uid.unwrap_or(1000);
        //     let gid = dev.user_gid.unwrap_or(uid);
        //     lines.push(format!(
        //         "RUN (getent group {gid} || groupadd -g {gid} {user}) || true"
        //     ));
        //     lines.push(format!("RUN (id -u {user} >/dev/null 2>&1 || useradd -m -u {uid} -g {gid} -s /bin/bash {user}) || true"));
        //     lines.push(format!(
        //         "RUN mkdir -p /home/{user}/.ssh && chown -R {user}:{user} /home/{user}"
        //     ));
        // }
        // lines.push("RUN mkdir -p /root/.ssh && chmod 700 /root/.ssh".into());

        let tpl = compile_str(DOCKERFILE).expect("Dockerfile template broken");
        let contents = tpl.render_data_to_string(&Data::Map(data)).unwrap();

        Ok(Self(contents))
    }

    pub fn write(&self, path: impl AsRef<Path>) -> Result<()> {
        fs::write(make_path(path), &self.0)?;
        Ok(())
    }
}

fn make_path(path: impl AsRef<Path>) -> PathBuf {
    match path.as_ref().file_name() {
        Some(name) if name.to_str() == Some(FILENAME) => path.as_ref().to_path_buf(),
        _ => path.as_ref().join(FILENAME),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn creates_expected_dockerfile_contents() {
        let extra = vec!["htop".to_string(), "ripgrep".to_string()];
        let df = Dockerfile::create("debian:bookworm", &extra, OsFamily::Debian).unwrap();
        let s = df.0;
        assert!(s.contains("FROM debian:bookworm"));
        // Base packages + extras in single line
        assert!(s.contains("RUN apt install -y curl ca-certificates git sudo htop ripgrep"));
        assert!(s.contains("CMD [\"sleep\", \"infinity\"]"));
    }

    #[test]
    fn equality_depends_on_rendered_contents() {
        let df1 = Dockerfile::create("img", &[], OsFamily::Debian).unwrap();
        let df2 = Dockerfile::create("img", &[], OsFamily::Debian).unwrap();
        let df3 = Dockerfile::create("img", &["vim".to_string()], OsFamily::Debian).unwrap();
        assert_eq!(df1, df2);
        assert_ne!(df1, df3);
    }

    #[test]
    fn write_and_open_roundtrip_and_exists() {
        let td = TempDir::new().unwrap();
        let df = Dockerfile::create("base", &[], OsFamily::Debian).unwrap();
        assert!(!Dockerfile::exists(td.path()));
        df.write(td.path()).unwrap();
        assert!(Dockerfile::exists(td.path()));
        let read = Dockerfile::open(td.path()).unwrap();
        assert_eq!(df, read);

        // Also check passing full file path works
        let file_path = td.path().join(FILENAME);
        let read2 = Dockerfile::open(&file_path).unwrap();
        assert_eq!(df, read2);
    }
}
